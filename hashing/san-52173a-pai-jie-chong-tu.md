### 散列:排解冲突

1.多槽位法\(multiple slots\)  
\(1\)桶单元细分成若干槽位\(slot\), 存放\(与同一单元\)冲突的词条  
\(一山不容二虎,若真有二虎,用铁丝网隔开\)  
\(2\)查找过程需要多出一步,还需要遍历桶中所有槽位  
\(3\)缺陷:槽位数无法预测,分的过细浪费,而且有可能发生大规模冲突

2.泾渭分明\(独立链,使用closed addressing\)  
\(1\)改用链表\(list\) : linked-list chaining / separate chaining  
\(2\)每个桶存放一个指针, 冲突的词条,组织成链表  
\(3\)优点:无需为每个桶预备多个槽位,任意多次的冲突都可解决,删除操作实现简单,统一  
\(4\)缺点:指针需要额外空间,节点需要动态申请,时间成本高出10^2  
\(5\)最大缺陷:空间未必连续分布,系统缓存几乎失效  
\(系统很难预测访问方向,无法加速查找,当hash表规模非常大,以至于不得不借助IO,这一矛盾就更加突出\)

3.开放地址\(Open addressing\)  
\(1\)使用Closed addressing,事先注定了某个词条对应某个桶  
\(2\)反其道而行,采用开放定址策略\(Open addressing\)  
\(3\)特点:散列表所占用的空间在物理上始终是地址连续的一块,所有的冲突都在这块连续的空间中排解,无需额外空间.  
\(4\)也称为闭散列\(Closed hashing\)

\(5\)Open addressing ~ closed hashing  
\(6\)为每个桶都_事先约定_若干_备用桶_, 构成一个查找链\(probing sequence/chain\)  
\(7\)在特定的情况下,每一个词条都有可能存放在任何一个桶中,但是对每一个特定词条,每个桶都有不同优先级.  
\(8\)优先级最高的是它本来就应该归属的那个桶  
\(9\)从最优桶开始,所有的桶都按照某种优先级关系排成一个序列,查找对应词条的时候顺次尝试每一个桶单元  
\(10\)每个词条所对应的序列,称作试探序列/查找链\(probing sequence/chain\)  
\(11\)沿着查找链逐个查找,命中,成功;或者抵达空桶\(已遍历所有冲突的词条\),失败

4.线性试探\(Linear probing\)  
\(1\)一旦冲突,则试探后一紧邻桶单元,直到命中成功,或抵达空桶失败  
\[hash\(key\)+1\] % M  
\[hash\(key\)+2\] % M  
\[hash\(key\)+3\] % M  
...  
优点  
\(2\)除了数据词条,无需任何附加空间\(指针,链表,或溢出区等\)  
\(3\)查找链具有_局部性_,可充分利用系统缓存,有效减少I/O  
缺点  
\(4\)操作时间 &gt; O\(1\)  
\(5\)冲突增多:以往的冲突,会导致后续的冲突\(clustering\)

5.懒惰删除\(Lazy removal\)  
\(1\)按照开放定址策略:先后插入,相互冲突的一组词条,将存放于同一查找链中  
\(2\)若要删除其中某一词条,应如何实现?  
\(3\)直接删除:清除词条,回收空桶? 问题:查找链切断,后续词条丢失,存在却访问不到  
\(4\)懒惰删除:仅做删除标记,查找链不必续接;

\(5\)查找到删除位置时,不中断继续查找  
\(6\)插入时直接插入删除位置

6.平方试探\(Quadratic probing\)  
\(1\)前面两种方法,封闭定址和开放定址,后者的物理结构更为紧凑,在性能上略具优势\(尤其是大规模的数据\)  
\(2\)然而,以上方法典型的线性试探策略,往往存在大量本不该发生的冲突.这一节改进.  
\(3\)线性试探,位置间距太近,集中于相对小的局部

\(4\)平方试探:以平方数为距离,确定下一试探桶单元  
\[ hash\(key\) + 1^2 \] % M  
\[ hash\(key\) + 2^2 \] % M  
\[ hash\(key\) + 3^2 \] % M  
\[ hash\(key\) + 4^2 \] % M  
...  
\(5\)相对于M取模后,可以保证所有的试探位置都在封闭的散列空间中

7.一利一弊  
\(1\)利:数据聚集现象缓解  
\(2\)弊:若涉及外存,I/O将激增

\(3\)附加问题:散列表中明明存在空桶,按这种策略却永远不能发现  
\(4\)附加问题证明:M是非素数,n^2%M可能的取值必然&lt;ceil\(M/2\)种,只要对应的桶都非空,永远发现不了别的空桶  
\(5\)附加问题证明:M是素数,n^2%M可能的取值恰好=ceil\(M/2\)种,此时恰由查找链的前ceil\(M/2\)项取遍\(恰恰超过50%\)  
\(6\)只要表长是素数,而且能够保证装填因子不超过50%,就一定不会发生以上的负面情况  
\(7\)装填因子是啥来着:实际使用桶数/散列表长度\(总桶数\)

8.至多半载  
否则可能有空桶却无法找到并且利用  
定理: 若M是素数,且装填因子&lt;=0.5,就一定能找出,否则不一定

9.M + LAMBDA  
证明以上结论\(暂略\)

10.双蜓点水\(双向平方试探\)  
交替向前向后以递增的平方数为间隔试探  
\(没看完\)

11.4K + 3  
\(没看\)

12.双平方定理  
\(没看\)

13.泾渭分明  
\(没看\)

