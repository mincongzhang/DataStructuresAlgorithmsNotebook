## 散列函数

1.无法杜绝的冲突  
\(1\)散列函数hash\(\):是映射,但不能一一映射\(单射\)  
\(2\)所以要精心设计散列表和散列函数,尽可能降低冲突的概率  
\(3\)并且需要制定可行的预案,当发生冲突时尽快排解

2.什么样的散列函数hash\(\)更好?  
\(1\)确定性\(determinism\):同一关键码总是被映射至同一地址  
\(2\)快速\(efficiency\):expect O\(1\)  
\(3\)满射\(surjection\):尽可能充分地覆盖整个散列空间  
\(4\)均匀\(uniformity\):关键码映射到散列表各位置的概率尽量接近,可有效避免聚集\(clustering\)现象

### 散列函数方法1:除余法  
\(1\)hash\(key\) = key % M  
\(2\)前面的例子中,为何选M = 90001? 而不是选2的k次方以高效计算\(用位与运算\)?

其实可以选M = 2^k? 而且计算余数方便: k%M = k&\(M-1\)  
但是结果却是最后k位相同的概率大, 违背了均匀分布的性质  
M为素数时, 覆盖最充分, 分布最均匀  
\(我的想法:素数是相对于我们常用的十进制来说的,假如用别的进制,我们定义的素数就没用了?\)

\(3\)以上方法破坏了均匀性:在整个关键码的取值空间中,存在某个特定的子集,该子集中的每一个元素都会统一的映射到散列表中的某一个特定单元,而不是均匀的分布于整个散列表中  
\(4\)取90001可稍有改进,但更好的方法是取M为_素数\(Prime number\)_  
\(5\)这样不仅数据对散列表的覆盖程度能够达到最充分,而且分布将达到最均匀

##### e.g.以蝉为师\(也就是使用素数做散列表长度\)

\(1\)我们处理的数据通常具有局部性, 可能带有一定的规律, 比如在循环中递增的序列等  
\(2\)选取素数,任何序列步长和该素数的最大公因子\(Greatest Common Divisor,G.C.D.\)都是1  
\(3\)并且任何步长都能遍历整个散列表空间\(具有均匀性\)  
\(4\)蝉的生命周期都是素数\(11,13,17等\),这样能尽量避免与其天敌的生命周期\(强盛期\)重合.  
\(5\)例子:  
按3的步长递增的数据, 然后用13做为散列表长

```
0 3 6 9 12 =>　0 3 6 9 12
15 18 21 24 27　=> 2 5 8 11 1
```

### M.A.D法\(改进除余法\)  
\(1\)除余法均匀性缺陷:  
-不动点:无论表长M取值如何,总有hash\(0\)==0  
-零阶均匀:\[0,R\)的关键码,平均分配至M个桶;但相邻关键码的散列地址也必相邻\(低阶均匀\)  
-一阶均匀:邻近关键码, 散列地址不邻近

\(2\)实现高阶均匀性:  
MAD = multiply-add-divide  
取M为素数,a&gt;0,b&gt;0,a%M!=0  
hash\(key\) = \(a\*key+b\) % M

\(3\)以上的a和b:  
b可视作偏移量\(offset\)可消除不动点;  
a为步长,原本相邻的关键码,将变成间隔a,从而不再相邻.

\(4\)其他场合可能未必需要高阶均匀性:  
-几何计算:尽可能使得临近的关键码,被映射到临近的位置\(locality sensitive hashing\)  
-密码学:小空间映射到大空间\(而不是通常的大空间映射到小空间\)

### 平方取中  
\(1\)数字分析\(selecting digits\)  
抽取key中的某几位,构成地址\(比如,取十进制表示的奇数位\)\(但没有均匀性\)  
\(2\)平方取中\(mid-square\)  
取key^2的中间若干位,构成地址  
hash\(123\)= 512; //key^2 = 123^2 = 1 512 9  
hash\(1234567\) = 556; //1234567^2 = 15241 556 77489  
\(3\)平方取中的原理?  
为了使得构成原关键码的各数位, 能够对最终的散列地址有尽可能接近的影响.  
平方操作可分解为一系列的左移操作以及若干次加法,居中的数位由更多的原数位累积而得.  
截取居中的若干位,可以使得原关键码的各数位对最终地址的影响彼此更为接近

### 折叠汇总  
\(1\)折叠法\(folding\)  
将key分割成_等宽_的若干段,取其_总和_作为地址  
hash\(123456789\)=1368 //123+456+789 自左向右  
hash\(123456789\)=1566 //123+654+789 往复折返  
\(2\)位异或法\(XOR\)  
将key分割成_等宽_的二进制段,经XOR运算得到地址  
hash\(110 011 011\)=110 //110^011^011 自左向右  
hash\(110 011 011\)=011 //110^110^011 往复折返

\*总之,越是随机,越是没有规律,越好

##### e.g.伪随机数  
\(1\)计算机中的随机数,实际上都是在前一个所谓随机数基础上,按照确定的计算规则递推而得的. 称为伪随机数发生器  
rand\(x+1\) = \[a \* rand\(x\)\] % M //M为素数  
\(2\)就逻辑效果而言,等同于将取之方位内的所有整数,按照这种规律重新排为一个貌似随机实则确定的序列; 发生器所返回的是在这个序列中对应于某个特定秩\(x\)的那个元素  
\(3\)最常见的方法,是将这个秩\(x\)取作系统当前的时间

\(4\)伪随机数法  
径取: hash\(key\) = rand\(key\) = \[rand\(0\) \* a^key\] % M  
种子: rand\(0\) = ?  
\(5\)确定+高效+满射+均匀, 是散列和随机数的重要标准

\(6\)伪随机数发生器的实现,因具体平台,不同历史版本而异; 创建的散列表可_移植性_差, 需慎用

### 多项式法\(转换字符串型关键码\)  
\(1\)关键码\(key\)预处理, 转化为整数, 成为散列码 \(hashcode\), 再map到bucket addr.  
\(2\)hash\( s = X0 X1 ... Xn-1 \) = x0 a^\(n-1\) + x1 a^\(n-2\) + x\(n-2\)a^1 + x\(n-1\) //a为某一常数  
\(3\)O\(n\)复杂度  
\(4\)近似多项式

```
static size_t hashCode( char s[] ){
int h=0;
for( size_t n=strlen(s),i=0; i<n; i++ ){
h = (h<<5 | h>>27);
h+= (int)s[i];
}

return (size_t)h;
}//适用于英文字符串
```

##### e.g 如果每个字符由一个数字代替,计算总和得hashcode,会导致频繁的冲突
   Tom Marvolo Riddle
   I am Lord Voldemort

